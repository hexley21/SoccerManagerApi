package argon2

import (
	"crypto/rand"
	"encoding/base64"
	"io"
	"strings"

	"github.com/hexley21/soccer-manager/pkg/config"
	"github.com/hexley21/soccer-manager/pkg/hasher"
	"golang.org/x/crypto/argon2"
)

type argon2Hasher struct {
	cfg config.Argon2
}

func NewHasher(hasherCfg config.Argon2) *argon2Hasher {
	return &argon2Hasher{cfg: hasherCfg}
}

// HashPassword hashes a password using the Argon2id algorithm and includes an autogenerated salt.
func (h *argon2Hasher) HashPassword(password string) (string, error) {
	saltInBytes, err := h.GetSalt()
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString(
		base64.RawStdEncoding.EncodeToString(
			argon2.IDKey(
				[]byte(password),
				saltInBytes,
				h.cfg.Time,
				h.cfg.Memory,
				h.cfg.Threads,
				h.cfg.KeyLen,
			),
		),
	)
	sb.WriteString(base64.RawStdEncoding.EncodeToString(saltInBytes))

	return sb.String(), nil
}

// HashPasswordWithsalt hashes a password using the Argon2id algorithm and includes a passed salt.
func (h *argon2Hasher) HashPasswordWithSalt(password string, salt string) (string, error) {
	decodedSalt, err := base64.RawStdEncoding.DecodeString(salt)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString(
		base64.RawStdEncoding.EncodeToString(
			argon2.IDKey(
				[]byte(password),
				decodedSalt,
				h.cfg.Time,
				h.cfg.Memory,
				h.cfg.Threads,
				h.cfg.KeyLen,
			),
		),
	)
	sb.WriteString(salt)

	return sb.String(), nil
}

// VerifyPassword verifies a password against a given hash.
func (h *argon2Hasher) VerifyPassword(password string, hash string) error {
	// extract salt from the password
	salt := hash[h.cfg.Breakpoint:]

	// hash the provided password with old hash's salt
	newHash, err := h.HashPasswordWithSalt(password, salt)

	if err != nil {
		return err
	}

	if newHash == hash {
		return nil
	}

	return hasher.ErrPasswordMismatch
}

// GetSalt generates a random slice of bytes with length of SaltLen
func (h *argon2Hasher) GetSalt() ([]byte, error) {
	salt := make([]byte, h.cfg.SaltLen)
	_, err := io.ReadFull(rand.Reader, salt)
	if err != nil {
		return nil, err
	}

	return salt, nil
}
